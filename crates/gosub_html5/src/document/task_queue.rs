use std::collections::HashMap;
use gosub_shared::traits::document::Document;
use crate::DocumentHandle;

use gosub_shared::byte_stream::Location;
use gosub_shared::node::NodeId;
use gosub_shared::traits::css3::CssSystem;
use gosub_shared::traits::node::{ElementDataType, Node};

/// Enum of tasks that can be performed to add or
/// update nodes in the tree.
///
/// These tasks are generated by a TreeBuilder which is implemented
/// by DocumentTaskQueue which holds a handle to the actual Document
/// to commit changes to.
pub enum DocumentTask {
    CreateElement {
        name: String,
        namespace: String,
        parent_id: NodeId,
        position: Option<usize>,
        location: Location,
    },
    CreateText {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    CreateComment {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    InsertAttribute {
        key: String,
        value: String,
        element_id: NodeId,
    },
}

/// Queue of tasks that will mutate the document to add/update
/// nodes in the tree. These tasks are performed sequentially in the
/// order they are created.
///
/// Once tasks are queued up, a call to flush() will commit all changes
/// to the DOM. If there are errors during the application of these changes,
/// flush() will return a list of the errors encountered but execution is not halted.
///
/// create_element() will generate and return a new NodeId for the parser to keep
/// track of the current context node and optionally store this in a list of open elements.
/// When encountering a closing tag, the parser must pop this ID off of its list.
pub struct DocumentTaskQueue<D: Document<C>, C: CssSystem> {
    /// Internal counter of the next ID to generate from the NodeArena
    /// without actually registering the node.
    /// WARNING: if nodes are registered in the arena while tasks are being queued
    /// this could lead to conflicts in NodeIds. NodeArena should NOT be used directly
    /// if using a DocumentTaskQueue.
    #[allow(dead_code)]
    next_node_id: NodeId,
    /// Reference to the document to commit changes to
    pub(crate) document: DocumentHandle<D, C>,
    /// List of tasks to commit upon flush() which is cleared after execution finishes.
    // IMPLEMENTATION NOTE: using a vec here since I'm assuming we are
    // executing all tasks at once. If we need to support stopping task
    // execution midway, then maybe a real "queue" structure that pops
    // completed tasks is needed.
    pub(crate) tasks: Vec<DocumentTask>,
}

impl<D: Document<C>, C: CssSystem> DocumentTaskQueue<D, C> {
    pub fn is_empty(&self) -> bool {
        self.tasks.is_empty()
    }

    #[allow(dead_code)]
    fn flush(&mut self) -> Vec<String> {
        let errors = Vec::new();
        for current_task in &self.tasks {
            match current_task {
                DocumentTask::CreateElement {
                    name,
                    namespace,
                    parent_id,
                    position,
                    location,
                } => {
                    let node = D::new_element_node(
                        self.document.clone(),
                        name,
                        Some(namespace),
                        HashMap::new(),
                        location.clone(),
                    );
                    self.document.get_mut().register_node_at(&node, *parent_id, *position);
                }
                DocumentTask::CreateText {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = D::new_text_node(self.document.clone(), content, location.clone());
                    self.document.get_mut().register_node_at(&node, *parent_id, None);
                }
                DocumentTask::CreateComment {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = D::new_comment_node(self.document.clone(), content, location.clone());
                    self.document.get_mut().register_node_at(&node, *parent_id, None);
                }
                DocumentTask::InsertAttribute {
                    key,
                    value,
                    element_id,
                } => {
                    if let Some(node) = self.document.get_mut().node_by_id_mut(*element_id) {
                        if let Some(mut data) = node.get_element_data_mut() {
                            data.attributes_mut().insert(key.clone(), value.clone());
                            // let mut attributes = node.get_element_data().unwrap().attributes().clone();
                            // attributes.insert(key.clone(), value.clone());
                            // data.set_attributes(&attributes);
                        }
                    }
                }
            }
        }
        self.tasks.clear();

        errors
    }
}

